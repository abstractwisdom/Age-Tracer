################
# Par-Spa v5.1 #
################

##############
# 03/09/2015 #
##############

###################################
# Particle Spawning python script #
###################################

#########################################################################################
# Currently works with:  hdf/intel/5-1.8.9   netcdf/intel/4.2.1   python/anaconda/2.2.0 #
#########################################################################################

#########################################################################
# Developers Matthew Bone(1), Martin Johnson(1), Tiago Silva(2)         #
# (1) UEA - University of East Anglia                                   #
# (2) Cefas - Centre for environment, fisheries and aquaculture science #
#########################################################################

import csv
from netCDF4 import Dataset
import numpy as np


# This script generate a csv file with particle locations and depths which spawn particles into model output data that already exists (eg. post processing for maximum gain of already existing data).
# Current use (02/09/2015) is as age an tracer experiment for the investigation of denitrification on the European Contintenal Shelf.



##########################
#  USER DEFINED INPUTS   #
##########################

# Define + open netcdf physical model - used for grid and bathymetry here, don't need more than 1 timestep
# Replace "north_west_european_shelf.3d.200110.3h.nc with your model data"
model_output = "north_west_european_shelf.3d.200110.3h.nc"


# Change p_box to determine how many particles will be released at each location
# Number of particles per grid square
# Value must be greater than 1
p_box = 2

# Specify date and time according to the start time of inputfile: lag_getm.inp
date = "2001/10/01 01:00:00"

# Name of output spawn csv particle file
out_file = "spawn.csv"

## define box areas
boxes = [
         #each line describes one rectilinear area (box) for particle addition
         #[[lat1,lat2],[lon1,lon2]],
         [[58,58.4],[-8,-7.6]],
         ]


# model lat and lon grid spacing - useful to avoid putting too many particles in one grid box - if too small you may get more particles than intednded per grid square, if too big you might miss some grid squares out. If$
lat_grid_spacing = 0.05
lon_grid_spacing = 0.08


#####################################################################
#  THE HACKING LINE  #  BE SURE YOU TO CROSS THIS AT YOUR OWN DOING #
#####################################################################



## var dataset is created by using the function that was imported at the top of the file from module netCDF4 which is a custom load module.
dataset = Dataset(model_output,'r')

## Numbers each particles, do not change value from 0.
p_box_count = 0


## This is 2 individual points
## This needs to be changed
## Write a function to determine location of particle release based on the depth using var dataset
##locations=[[-6.1,58.5],[-9.6,54]]

def list_boxlocations(lat_range,lon_range):
    '''produces a list of lon-lat combinations to spawn particles in a given area defined by inputs. input arrays generated by np.arange as e.g. np.arange(48,56,0.08) where 0.08 is grid interval '''

    #example usage
    #note always put more negative number first otherwise nprange breaks
        #spawn1_lon = (np.arange(-16.5,-4, 0.08))
        #spawn1_lat = (np.arange(48, 56.5, 0.05))

        #spawnlist(spawn1_lon,spawn1_lat)


    a = [list(lat_range),list(lon_range)]
#    print a
    r=[[]]
    #this bit magically expands to all combinations using python voodoo
    for x in a:
        r=[ i + [y] for y in x for i in r ]

    return r




def brute_force_location_index(latvar,lonvar,lat0,lon0):
    '''This goes through all latvar and lonvar values and picks out the shortest distance from lat0 and lon0 and looks up the nearest location in model grid coordinates'''
    # example usage
    #iy,ix = brute_force_location_index(latvar, lonvar, 59, -6)
    #print('Closest lat lon:', latvar[iy,ix], lonvar[iy,ix])

    ## Northings
    latvals = latvar[:]
    ## Eastings
    lonvals = lonvar[:]
    ## Northings
    ny = latvals.shape[0]
    ## Eastings
    nx = lonvals.shape[0]
    ## dynamic value used in, if dist_sq < dist_sq_min:
    dist_sq_min = 1.0e30
    ## Itterat through all points on an x y grid.
    for iy in range(ny):
        for ix in range(nx):
            latval = latvals[iy]
            lonval = lonvals[ix]
            dist_sq = (latval - lat0)**2 + (lonval - lon0)**2
            if dist_sq < dist_sq_min:
                iy_min = iy
                ix_min = ix
                dist_sq_min = dist_sq
    return iy_min, ix_min

def createspawnlist_singlelocation(nparticles, latitude, longitude, date, model_output):

    ''' creates a list of particle spawn points over depth range, for a single grid square and time '''
    #distance from bottom of deepest particle realease - (0.1cm?)
    bottom_scrape = 0.1
    ## nparticles is p_box
    global p_box_count
    ##This numbers the range of particles to be spawned
    o = range(p_box_count, p_box_count + nparticles)
    p_box_count = p_box_count + nparticles
    p = list(o) #number of particle
    ## these to get handed to
    ## def brute_force_location_index(latvar,lonvar,lat0,lon0):
    ## that are use togther as x y coordinates
    ## Existing latitude and longitude locations within the module run
    latvar = model_output.variables['latc']
    lonvar = model_output.variables['lonc']
    # Get netcdf x and y indexes for lon lat position
    ##Function inside a function - aka requires the previous function (brute_force_location_index) to work!
    iy, ix = brute_force_location_index(latvar, lonvar, latitude, longitude)
    depth = dataset.variables['bathymetry'][iy,ix]
    depthinterval = (depth - bottom_scrape)/(nparticles-1)
    #create list of lists to write out file - first particle is particle number
    ## var particle comes from itterating through the list p
    ## p comes from, p = list(range(nparticles))
    ## nparticles comes from p_box. And is handed to this function as a parameter.
    ## so p is a simple list
    ## here it is writen particle+1 so as to adjust for counting from 0
    ## latitude,longitude,
    list_of_lists = [[particle+1,latitude,longitude,(particle)*depthinterval,date] for particle in p]
    return list_of_lists

#print "offshore"
#test = createspawnlist_singlelocation(10,58.1,-10,date,dataset)

#print "shallow"
#test = createspawnlist_singlelocation(10,59,-6,date,dataset)

#print "north sea"
#test = createspawnlist_singlelocation(10,53,3,date,dataset)

#print "land"
#test = createspawnlist_singlelocation(10,57,-4,date,dataset)

#print "out of range"
#test = createspawnlist_singlelocation(10,-8,57,date,dataset)




master_list=[]
# for each user-defined box...
for box in boxes:
    # Munge the data into the format required by def list_boxlocations(lon_range,lat_range)

    latrange = box[0]
    lonrange = box[1]

    box_latrange = np.arange(latrange[0],latrange[1],lat_grid_spacing)
    box_lonrange = np.arange(lonrange[0],lonrange[1],lon_grid_spacing)

    #input into the function
    box_locations = list_boxlocations(box_latrange,box_lonrange)

    box_spawnlists = [createspawnlist_singlelocation(p_box,   location[0],    location[1],    date,
dataset) for location in box_locations]
    master_list = box_spawnlists


############################################################
##         Needs to loop through all locations?           ##
############################################################
#for master in box_spawn
#    master_list[0]+ master_list[:]
#return master_list

#    box_list_of_lists=box_spawnlists[0]+box_spawnlists[1]
#    print box_list_of_lists
#    master_list = master_list+box_list_of_lists

## func createspawnlist_singlelocation, 5 parameters
## var input is p_box fixed at int 50, within the function def its called nparticles
## var input is location[0]
## var input is location[1]
## var input is date, a string defined earlier - fixed starting value, within the function is ALSO called "date"
## var input is dataset, this is a 2d matrix. Within the function it is called "model_output"

#lists = [createspawnlist_singlelocation(p_box,    location[0],    location[1],    date,    dataset,    1000) for location in locations]

## >>> c = [[1,2,3],[4,5,6]]
## >>> c
## [[1, 2, 3], [4, 5, 6]]
## >>> d = c
## >>> d[0]+d[1]
## [1, 2, 3, 4, 5, 6]
## This removes the brakets from the data to ensure it is in the right format for the model script
#list_of_lists=lists[0]+lists[1]


## Writes list_of_lists to file.
with open(out_file,"w") as f:
    wr = csv.writer(f, delimiter= ' ')
    wr.writerow([p_box_count])
    wr.writerows(master_list)
